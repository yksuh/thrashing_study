/*
* Copyright (c) 2012, Arizona Board of Regents
* 
* See LICENSE at /cs/projects/tau/azdblab/license
* See README at /cs/projects/tau/azdblab/readme
* AZDBLab, http://www.cs.arizona.edu/projects/focal/ergalics/azdblab.html
* This is a Laboratory Information Management System
* 
* Authors:
* Matthew Johnson 
* Rui Zhang (http://www.cs.arizona.edu/people/ruizhang/)
*/
package azdblab.model.dataDefinition;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Vector;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;

import azdblab.Constants;
import azdblab.exception.analysis.DataDefinitionValidationException;
import azdblab.exception.analysis.NameResolutionException;
import azdblab.executable.Main;
import azdblab.labShelf.GeneralDBMS;
import azdblab.model.experiment.XMLHelper;

/**
 * The data definition module handles the XML document type Data Definition. The
 * data definition defines the tables and referential integrity of the
 * experiment tables. It also specifies how the data will be generated by the
 * data generator.
 * 
 * @author Kevan Holdaway
 * 
 */
public class DataDefinition {

	/**
	 * Represents an experiment table.
	 * 
	 * @author Kevan Holdaway
	 * 
	 */
	private class Table {
		/**
		 * @param t
		 *            The XML table element for this table.
		 * @param colMap
		 *            A hashmap that contains the columns of this table.
		 * @param cols
		 *            The names of the columns of this table.
		 */
		public Table(Element t, HashMap<String, Element> colMap, String[] cols,
				String[] primary_key) {
			table = t;
			columnMap = colMap;
			columns = cols;
			primaryKey = primary_key;
		}

		public Table(Element t, HashMap<String, Element> colMap, String[] cols,
				String[] primary_key, String[] uniqueCols, String[] indexCols) {
			table = t;
			columnMap = colMap;
			columns = cols;
			primaryKey = primary_key;
			uniques = uniqueCols;
			index_cols = indexCols;
		}
		
		/**
		 * A map from column name to column objects.
		 */
		public HashMap<String, Element> columnMap;

		/**
		 * A vector of columns specified as sorted one
		 */
		public String[] sortedOns;

		/**
		 * A vector of columns specified as unique
		 */
		public String[] uniques;

		/**
		 * The names of the columns.
		 */
		public String[] columns;

		/**
		 * The column names of the hash index.
		 */
		public String[] hashIdxColumns;

		/**
		 * The column names of the btree index.
		 */
		public String[] btreeIdxColumns;

		public String[] primaryKey;
		public String[] index_cols;
		/**
		 * The XML document for this table.
		 */
		public Element table;

	}

	/**
	 * Constructs the data definition module from the XML.
	 * 
	 * @param root
	 *            The root XML element of the data definition.
	 * @throws IOException
	 *             If there is a problem writing to the file.
	 * @throws DataDefinitionValidationException
	 *             If there is a validation problem with the data definition
	 *             XML.
	 * @throws NameResolutionException
	 *             If there is a name resolution problem inside the data
	 *             definition.
	 */
	public DataDefinition(Element root) throws IOException,
			DataDefinitionValidationException, NameResolutionException {

		myDataDef = File.createTempFile("dataDefinition", ".xml", new File(
				Constants.DIRECTORY_TEMP));
		myDataDef.deleteOnExit();
		FileOutputStream out = new FileOutputStream(myDataDef);
		XMLHelper.writeXMLToOutputStream(out, root);
		out.close();
		init();

	}

	/**
	 * Constructs the data definition module from the XML contained in the file
	 * passed in as a parameter.
	 * 
	 * @param href
	 *            The location of the XML file containing the data definition
	 *            XML.
	 * @throws DataDefinitionValidationException
	 *             If there is a validation problem with the data definition
	 *             XML.
	 * @throws FileNotFoundException
	 *             If the href points to an file that cannot be found.
	 * @throws NameResolutionException
	 *             If there is a name resolution problem inside the data
	 *             definition.
	 */
	// public DataDefinition(String href)
	// throws DataDefinitionValidationException, FileNotFoundException,
	// NameResolutionException {
	// myDataDef = new File(href);
	// init();
	// }

	/**
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	public boolean equals(Object o) {
		if (!(o instanceof DataDefinition))
			return false;
		DataDefinition other = (DataDefinition) o;
		if (!other.getDataDefName().equals(myName))
			return false;
		String[] otherTables = other.getTables();
		String[] thisTables = this.getTables();

		// tests to make sure that there are the same number of tables.
		if (otherTables.length != thisTables.length)
			return false;
		// compares each table to see if they are the same.
		for (int i = 0; i < otherTables.length; i++) {
			String ot = otherTables[i];
			String tt = thisTables[i];
			if (!ot.equals(tt)) // same table name
				return false;
			if (other.getTableCardinality(ot) != this.getTableCardinality(tt))
				return false;
			if (other.getTablePrimaryKey(ot) == null
					&& this.getTablePrimaryKey(tt) != null)
				return false;
			if (other.getTablePrimaryKey(ot) != null
					&& this.getTablePrimaryKey(tt) == null)
				return false;
			if (other.getTablePrimaryKey(ot) != null
					&& this.getTablePrimaryKey(tt) != null
					&& !other.getTablePrimaryKey(ot).equals(
							this.getTablePrimaryKey(tt)))
				return false;
			String otherColumns[] = other.getTableColumns(ot);
			String thisColumns[] = this.getTableColumns(tt);

			// checks to see that each table has the same number of columns.
			if (otherColumns.length != thisColumns.length)
				return false;

			// for each column, make sure they are the same.
			for (int j = 0; j < otherColumns.length; j++) {
				String oc = otherColumns[j];
				String tc = thisColumns[j];
				if (!oc.equals(tc))
					return false;
				if (other.getColumnDataGenType(ot, oc) != this
						.getColumnDataGenType(tt, tc))
					return false;
				if (other.getColumnDataLength(ot, oc) != this
						.getColumnDataLength(tt, tc))
					return false;
				if (other.getColumnDataType(ot, oc) != this.getColumnDataType(
						tt, tc))
					return false;
				if (other.getColumnMaxValue(ot, oc) != this.getColumnMaxValue(
						tt, tc))
					return false;
				if (other.getColumnMinValue(ot, oc) != this.getColumnMinValue(
						tt, tc))
					return false;
			}

			// checks to see that the foreign keys are the same
			ForeignKey[] otherKeys = other.getTableForeignKeys(ot);
			ForeignKey[] thisKeys = this.getTableForeignKeys(tt);
			if (otherKeys == null && thisKeys != null)
				return false;
			if (otherKeys != null && thisKeys == null)
				return false;
			if (otherKeys != null && thisKeys != null
					&& otherKeys.length != thisKeys.length)
				return false;
			for (int j = 0; otherKeys != null && j < otherKeys.length; j++) {
				if (!otherKeys[j].equals(thisKeys[j]))
					return false;
			}
		}

		return true;
	}

	/**
	 * Given a table and column return the data generation type. This will
	 * indicate whether the generation is sequential or random
	 * 
	 * @param table
	 *            The name of the table
	 * @param column
	 *            The column of the table.
	 * @return The data generation type.
	 */
	public int getColumnDataGenType(String table, String column) {
		String dataGenType = ((Element) ((Table) myElementTableMap.get(table)).columnMap
				.get(column)).getAttribute("dataGenerationType");
		if (dataGenType.equals(Constants.S_GEN_TYPE_RANDOM)) {
			return Constants.I_GEN_TYPE_RANDOM;
		} else { // if(dataType.equals(SEQUENTIAL)){
			return Constants.I_GEN_TYPE_SEQUENTIAL;
		}
	}

	/**
	 * Given a table and column, this returns the length of the data type, this
	 * is the size in the number of digits.
	 * 
	 * @param table
	 *            The name of the table.
	 * @param column
	 *            The column of the table.
	 * @return The size of this column in the number of digits.
	 */
	public int getColumnDataLength(String table, String column) {
		return Integer.parseInt(((Element) ((Table) myElementTableMap
				.get(table)).columnMap.get(column)).getAttribute("dataLength"));
	}

	/**
	 * Given a table and column, this returns the decimal point of the data type
	 * 
	 * @param table
	 *            The name of the table.
	 * @param column
	 *            The column of the table.
	 * @return The size of this column in the number of digits.
	 */
	public int getColumnDecimalPoint(String table, String column) {
		String dp = ((Element) ((Table) myElementTableMap
				.get(table)).columnMap.get(column)).getAttribute("decimalPoint");
		if(!dp.equalsIgnoreCase("")){
			return Integer.parseInt(dp);
		}
		return -1;	// no decimal point
	}
	
	/**
	 * Given a table and column name, returns the data type for that column.
	 * Returns the AZDBLab's integer representation of the data type.
	 * 
	 * @param table
	 *            The name of the table.
	 * @param column
	 *            The name of the column
	 * @return The data type of the column. Returned as AZDBLab's integer
	 *         representation.
	 */
	public int getColumnDataType(String table, String column) {
		String dataType = ((Element) ((Table) myElementTableMap.get(table)).columnMap
				.get(column)).getAttribute("dataType");
		if (dataType.equals(Constants.S_DATA_TYPE_NUMBER)) {
			return GeneralDBMS.I_DATA_TYPE_NUMBER;
		} else if (dataType.equals(Constants.S_DATA_TYPE_TIMESTAMP)) {
			return GeneralDBMS.I_DATA_TYPE_TIMESTAMP;
		} else if (dataType.equals(Constants.S_DATA_TYPE_CHAR)) {
			return GeneralDBMS.I_DATA_TYPE_VARCHAR;
		} else if (dataType.equals(Constants.S_DATA_TYPE_VARCHAR2)) {
			return GeneralDBMS.I_DATA_TYPE_VARCHAR;
		} else {
			Main._logger
					.reportError("DataDefinitionModule.getColumnDataType encountered unknown data type: "
							+ dataType);
			System.exit(1); // programmer error in xml schema
		}
		return 0;
	}

	/**
	 * Given a table name and column name, return a string representation of the
	 * data type.
	 * 
	 * @param table
	 *            The name of the table.
	 * @param column
	 *            The name of the column.
	 * @return The string representation of the data type.
	 */
	public String getColumnDataTypeASString(String table, String column) {
		String dataType = ((Element) ((Table) myElementTableMap.get(table)).columnMap
				.get(column)).getAttribute("dataType");
		return dataType;
	}

	/**
	 * Given a name of a table and column name, return the maximum value that
	 * will be produced for the data generator.
	 * 
	 * @param table
	 *            The name of the table
	 * @param column
	 *            The name of the column
	 * @return The maximum value that the data generator should produce for this
	 *         column's values.
	 */
	public long getColumnMaxValue(String table, String column) {
		return Long
				.parseLong(((Element) ((Table) myElementTableMap.get(table)).columnMap
						.get(column)).getAttribute("distributionMaximum"));
	}

	/**
	 * Given a name of a table and column name, return the minimum value that
	 * will be produced for the data generator.
	 * 
	 * @param table
	 *            The name of the table.
	 * @param column
	 *            The name of the column
	 * @return The minimum value that the data generator should produce for this
	 *         column's values.
	 */
	public long getColumnMinValue(String table, String column) {
		return Long
				.parseLong(((Element) ((Table) myElementTableMap.get(table)).columnMap
						.get(column)).getAttribute("distributionMinimum"));
	}

	/**
	 * Provides the name of the data definition.
	 * 
	 * @return The name of the data definition is returned.
	 */
	public String getDataDefName() {
		return myDocument.getDocumentElement().getAttribute("name");
	}

	/**
	 * Provides the XML root element.
	 * 
	 * @return The XML root element for the data definition.
	 */
	public Element getRoot() {
		return myDocument.getDocumentElement();
	}

	/**
	 * returns the cardinality of the given table.
	 * 
	 * @param table
	 *            The table whose cardinality will be returned.
	 * @return The cardinality of the given table.
	 */
	public long getTableCardinality(String table) {
		return Long.parseLong(((Table) myElementTableMap.get(table)).table
				.getAttribute("cardinality"));
	}

	/**
	 * Returns an array of column names. These are the name of the columns for
	 * the given table.
	 * 
	 * @param table
	 *            The name of the table whose columns are returned.
	 * @return The column names of the given table.
	 */
	public String[] getTableColumns(String table) {
		return ((Table) myElementTableMap.get(table)).columns;
	}

	/**
	 * Given a table name, it returns an array of the foreign keys for this
	 * table.
	 * 
	 * @param table
	 *            The name of the table whose foreign keys are returned.
	 * @return The foreign keys of the given table.
	 */
	public ForeignKey[] getTableForeignKeys(String table) {
		// RALOW implement this for indexes
		return null;
	}

	/**
	 * Given a table name, it returns the primary key of the table.
	 * 
	 * @param table
	 *            The name of the table whose primary key is returned.
	 * @return The primary key of the given table.
	 */
	public String[] getTablePrimaryKey(String table) {
		Table target_table = myElementTableMap.get(table);
		if (target_table != null) {
			return target_table.primaryKey;
		}
		return null;
	}
	/**
	 * Given a table name, it returns the index fields of the table.
	 * 
	 * @param table
	 *            The name of the table whose index fields are returned.
	 * @return The index fields of the given table.
	 */
	public String[] getTableIndexCols(String table) {
		Table target_table = myElementTableMap.get(table);
		if (target_table != null) {
			return target_table.index_cols;
		}
		return null;
	}
	
	/**
	 * The names of all tables in the data definition are returned.
	 * 
	 * @return The name of all tables in the data definition.
	 */
	public String[] getTables() {
		// RALOW this should return the tables in the correct order for
		// insertion (only matters with referential integrity
		return myTables;
	}

	/**
	 * Returns a handle to the XML source of this data definition.
	 * 
	 * @return The XML source of this data definition.
	 */
	public File getXMLFile() {
		return myDataDef;
	}

	/**
	 * Given a name of a table and column name, return all column names on which
	 * this table should be sorted.
	 * 
	 * @param table
	 *            The name of the table.
	 * @return all column names on which this table should be sorted.
	 */
	public String[] getSortedOnCols(String table) {
		return ((Table) myElementTableMap.get(table)).sortedOns;
	}

	/**
	 * Given a name of a table and column name, return all columns that have to
	 * have a unique constraint.
	 * 
	 * @param table
	 *            The name of the table.
	 * @return all columns that have to have a unique constraint.
	 */
	public String[] getTableUniqueCols(String table) {
		return ((Table) myElementTableMap.get(table)).uniques;
	}

	/**
	 * Given a name of a table and column name, return all columns that have to
	 * have a unique constraint.
	 * 
	 * @param table
	 *            The name of the table.
	 * @return all columns that have to have a unique constraint.
	 */
	public String[] getHashIndexColumns(String table) {
		return ((Table) myElementTableMap.get(table)).hashIdxColumns;
	}

	public String[] getBtreeIndexColumns(String table) {
		return ((Table) myElementTableMap.get(table)).btreeIdxColumns;
	}

	/**
	 * Called by the constructor to parse the data definition and store class
	 * variables.
	 * 
	 * @throws FileNotFoundException
	 */
	private void init() throws FileNotFoundException {
		// myDocument =
		// XMLHelper.validate((getClass().getClassLoader().getResourceAsStream(MetaData.CHOSEN_DATA_DEFINITION_SCHEMA)),
		// myDataDef);
		myDocument = XMLHelper.validate(new FileInputStream(new File(
				Constants.CHOSEN_DATA_DEFINITION_SCHEMA)), new FileInputStream(
				myDataDef));
		myName = myDocument.getDocumentElement().getAttribute("name");
		myElementTableMap = new HashMap<String, Table>();

		// Extract all the tables from the XML
		NodeList elementTables = myDocument.getDocumentElement()
				.getElementsByTagName("table");
		myTables = new String[elementTables.getLength()];
		for (int i = 0; i < elementTables.getLength(); i++) {
			// gathering information about a table
			Element table = (Element) elementTables.item(i);
			myTables[i] = table.getAttribute("name");

			// Note this list also contains the columns from referential
			// integrity, these are removed first
			NodeList rawColumns = table.getElementsByTagName("column");
			Vector<Node> columns = new Vector<Node>();
			Vector<String> vec_primary_key = new Vector<String>();
			Vector<String> vec_unique = new Vector<String>();
			Vector<String> vec_index = new Vector<String>();
			Vector<String> vec_decimal = new Vector<String>();
			for (int j = 0; j < rawColumns.getLength(); j++)
				if (!((Element) rawColumns.item(j)).getAttribute("dataType")
						.equals(Constants.EMPTY_STRING)) {
					columns.add(rawColumns.item(j));
					if (((Element) rawColumns.item(j)).getAttribute(
							"inPrimaryKey").equals("true")) {
						vec_primary_key.add(((Element) rawColumns.item(j))
								.getAttribute("name"));
					}
					if (((Element) rawColumns.item(j)).getAttribute(
							"inUnique").equals("true")) {
						vec_primary_key.add(((Element) rawColumns.item(j))
								.getAttribute("name"));
					}
					if (((Element) rawColumns.item(j)).getAttribute(
							"inIndex").equals("true")) {
						vec_primary_key.add(((Element) rawColumns.item(j))
								.getAttribute("name"));
					}
				}

			String[] columnKeys = new String[columns.size()];

			// creates a HashMap from column name to the element node
			HashMap<String, Element> columnMap = new HashMap<String, Element>();
			for (int j = 0; j < columns.size(); j++) {
				Element column = (Element) columns.get(j);
				columnKeys[j] = column.getAttribute("name");
				columnMap.put(columnKeys[j], column);
			}

//			// Note this list also contains columns to be indexed
//			NodeList rawIndexes = table.getElementsByTagName("index");
//			Vector<String> hashIndexColumns = new Vector<String>();
//			for (int j = 0; j < rawIndexes.getLength(); j++) {
//				if (((Element) rawIndexes.item(j)).getAttribute("type")
//						.equalsIgnoreCase("hash")) {
//					Element elem = (Element) rawIndexes.item(j);
//					NodeList rawHashIndexColumns = elem
//							.getElementsByTagName("column");
//					hashIndexColumns
//							.add(((Element) rawHashIndexColumns.item(0))
//									.getAttribute("name"));
//				} else if (((Element) rawIndexes.item(j)).getAttribute("type")
//						.equalsIgnoreCase("btree")) {
//					Element elem = (Element) rawIndexes.item(j);
//					NodeList rawBtreeColumns = elem
//							.getElementsByTagName("column");
//					hashIndexColumns.add(((Element) rawBtreeColumns.item(0))
//							.getAttribute("name"));
//				}
//			}

//			// sortedon element
//			// Note this list also contains columns on which this table should
//			// be sorted
//			NodeList rawSortedOn = table.getElementsByTagName("sortedon");
//			Vector<String> sortedOns = new Vector<String>();
//			for (int j = 0; j < rawSortedOn.getLength(); j++) {
//				Element sortedon = (Element) rawSortedOn.item(j);
//				NodeList rawSortedOnColumns = sortedon
//						.getElementsByTagName("column");
//				sortedOns.add(((Element) rawSortedOnColumns.item(0))
//						.getAttribute("name"));
//			}

//			// unique element
//			// Note this list also contains columns on which this table should
//			// be sorted
//			NodeList rawUnique = table.getElementsByTagName("unique");
//			Vector<String> uniques = new Vector<String>();
//			for (int j = 0; j < rawUnique.getLength(); j++) {
//				Element unique = (Element) rawUnique.item(j);
//				NodeList rawUniques = unique.getElementsByTagName("column");
//				uniques
//						.add(((Element) rawUniques.item(0))
//								.getAttribute("name"));
//			}

			String[] primaryKeys = null;
			if (vec_primary_key.size() > 0) {
				primaryKeys = new String[vec_primary_key.size()];
				Main._logger.outputLog("\nprimary key:-----------");
				for (int j = 0; j < vec_primary_key.size(); j++) {
					primaryKeys[j] = vec_primary_key.get(j);
					Main._logger.outputLog(primaryKeys[j] + ", ");
				}
				Main._logger.outputLog("");
			}

			String[] uniqueKeys = null;
			if (vec_unique.size() > 0) {
				uniqueKeys = new String[vec_unique.size()];
				Main._logger.outputLog("\nunique-----------");
				for (int j = 0; j < vec_unique.size(); j++) {
					uniqueKeys[j] = vec_unique.get(j);
					Main._logger.outputLog(uniqueKeys[j] + ", ");
				}
				Main._logger.outputLog("");
			}
			
			String[] indexFields = null;
			if (vec_primary_key.size() > 0) {
				indexFields = new String[vec_index.size()];
				Main._logger.outputLog("\nindex fields:-----------");
				for (int j = 0; j < vec_index.size(); j++) {
					indexFields[j] = vec_index.get(j);
					Main._logger.outputLog(indexFields[j] + ", ");
				}
				Main._logger.outputLog("");
			}
			// creates a mapping from a table name to a Table Object.
			// A table object contains an element table and a HashMap for its
			// columns.
			myElementTableMap.put(myTables[i], new Table(table, columnMap,
					columnKeys, primaryKeys));
			// myElementTableMap.put(myTables[i], new Table(table,
			// columnMap,
			// columnKeys,
			// sortedOns,
			// btreeIndexColumns,
			// hashIndexColumns,
			// uniques));
		}
	}

	/**
	 * Performs name resolution for the data definition. Currently this has not
	 * been implemented.
	 * 
	 * @throws NameResolutionException
	 *             If there is a name resolution error.
	 */
	// private void resolveNames() throws NameResolutionException {}

	/**
	 * Checks to see if the table name passed as a parameter is indeed a table
	 * defined in the data definition.
	 * 
	 * @param table
	 *            The name of the table that is being check for validity.
	 * @return true - if table is a table defined inside the data definition.<BR>
	 *         false - if the table is not a table defined inside the data
	 *         definition.
	 */
	public boolean tableIsValid(String table) {
		return myElementTableMap.containsKey(table);
	}

	/**
	 * The file containing the source of the data definition.
	 */
	private File myDataDef = null;
	/**
	 * The XML document that holds the source of the data definition.
	 */
	private Document myDocument = null;

	/**
	 * A map of the names of tables to the tables.
	 */
	private HashMap<String, Table> myElementTableMap = null;
	/**
	 * The name of the data definition.
	 */
	private String myName = null;
	/**
	 * The tables of the data definition.
	 */
	private String[] myTables = null;
}